package com.studymate.domain.session.service;

import com.studymate.domain.session.domain.dto.request.WebRtcJoinRequest;
import com.studymate.domain.session.domain.dto.request.WebRtcSignalingMessage;
import com.studymate.domain.session.domain.dto.response.WebRtcConnectionStatsResponse;
import com.studymate.domain.session.domain.dto.response.WebRtcParticipantResponse;
import com.studymate.domain.session.domain.repository.WebRtcRoomRepository;
import com.studymate.domain.user.entity.User;
import com.studymate.domain.user.domain.repository.UserRepository;
import com.studymate.exception.NotFoundException;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

@Slf4j
@Service
@RequiredArgsConstructor
@Transactional
public class WebRtcServiceImpl implements WebRtcService {

    private final WebRtcRoomRepository webRtcRoomRepository;
    private final UserRepository userRepository;
    private final SimpMessagingTemplate messagingTemplate;

    // 메모리 내 활성 연결 관리 (실제 프로덕션에서는 Redis 사용 권장)
    private final Map<String, Set<UUID>> activeConnections = new ConcurrentHashMap<>();
    private final Map<UUID, WebRtcConnectionStatsResponse> sessionStats = new ConcurrentHashMap<>();

    @Override
    public WebRtcParticipantResponse joinRoom(UUID roomId, WebRtcJoinRequest request) {
        log.info("사용자 {}가 방 {}에 참가 시도", request.getUserId(), roomId);
        
        SessionRoom room = sessionRoomRepository.findById(roomId)
                .orElseThrow(() -> new NotFoundException("세션 방을 찾을 수 없습니다."));
        
        User user = userRepository.findById(request.getUserId())
                .orElseThrow(() -> new NotFoundException("사용자를 찾을 수 없습니다."));

        // 기존 참가자 확인
        Optional<WebRtcParticipant> existingParticipant = webRtcParticipantRepository
                .findBySessionRoomAndUser(room, user);
        
        WebRtcParticipant participant;
        if (existingParticipant.isPresent()) {
            participant = existingParticipant.get();
            participant.rejoin();
        } else {
            // 새 참가자 생성
            boolean isHost = webRtcParticipantRepository.countBySessionRoom(room) == 0;
            
            participant = WebRtcParticipant.builder()
                    .sessionRoom(room)
                    .user(user)
                    .connectionId(generateConnectionId())
                    .isHost(isHost)
                    .isModerator(isHost)
                    .joinedAt(LocalDateTime.now())
                    .status(WebRtcParticipant.ParticipantStatus.JOINING)
                    .isCameraEnabled(request.getEnableCamera())
                    .isMicrophoneEnabled(request.getEnableMicrophone())
                    .userAgent(request.getUserAgent())
                    .deviceInfo(extractDeviceInfo(request.getUserAgent()))
                    .build();
        }
        
        participant = webRtcParticipantRepository.save(participant);
        
        // 활성 연결 맵에 추가
        activeConnections.computeIfAbsent(roomId.toString(), k -> new HashSet<>())
                .add(user.getUserId());
        
        // 다른 참가자들에게 새 참가자 알림
        notifyParticipantJoined(roomId, participant);
        
        // 세션 통계 초기화
        updateSessionStats(roomId);
        
        return convertToParticipantResponse(participant);
    }

    @Override
    public void leaveRoom(UUID roomId, UUID userId) {
        log.info("사용자 {}가 방 {}에서 나감", userId, roomId);
        
        SessionRoom room = sessionRoomRepository.findById(roomId)
                .orElseThrow(() -> new NotFoundException("세션 방을 찾을 수 없습니다."));
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new NotFoundException("사용자를 찾을 수 없습니다."));
        
        WebRtcParticipant participant = webRtcParticipantRepository
                .findBySessionRoomAndUser(room, user)
                .orElseThrow(() -> new NotFoundException("참가자를 찾을 수 없습니다."));
        
        // 참가자 상태 업데이트
        participant.leave();
        webRtcParticipantRepository.save(participant);
        
        // 활성 연결에서 제거
        Set<UUID> roomConnections = activeConnections.get(roomId.toString());
        if (roomConnections != null) {
            roomConnections.remove(userId);
            if (roomConnections.isEmpty()) {
                activeConnections.remove(roomId.toString());
                sessionStats.remove(roomId);
            }
        }
        
        // 다른 참가자들에게 퇴장 알림
        notifyParticipantLeft(roomId, participant);
        
        // 호스트가 나간 경우 다른 참가자를 호스트로 승격
        if (Boolean.TRUE.equals(participant.getIsHost())) {
            promoteNewHost(roomId);
        }
        
        updateSessionStats(roomId);
    }

    @Override
    public void handleSignalingMessage(UUID roomId, WebRtcSignalingMessage message) {
        log.debug("시그널링 메시지 처리: {} - {}", message.getType(), roomId);
        
        // 메시지 유효성 검증
        if (!isValidSignalingMessage(message)) {
            log.warn("유효하지 않은 시그널링 메시지: {}", message.getType());
            return;
        }
        
        // 메시지 타입별 처리
        switch (message.getType().toLowerCase()) {
            case "offer", "answer", "ice-candidate" -> handleWebRtcSignal(roomId, message);
            case "mute", "unmute" -> handleAudioControl(roomId, message);
            case "video-on", "video-off" -> handleVideoControl(roomId, message);
            case "screen-share-start", "screen-share-stop" -> handleScreenShare(roomId, message);
            default -> log.warn("알 수 없는 시그널링 메시지 타입: {}", message.getType());
        }
        
        // 연결 통계 업데이트
        updateConnectionStats(roomId, message);
    }

    @Override
    public List<WebRtcParticipantResponse> getRoomParticipants(UUID roomId) {
        SessionRoom room = sessionRoomRepository.findById(roomId)
                .orElseThrow(() -> new NotFoundException("세션 방을 찾을 수 없습니다."));
        
        List<WebRtcParticipant> participants = webRtcParticipantRepository
                .findActiveParticipantsByRoom(room);
        
        return participants.stream()
                .map(this::convertToParticipantResponse)
                .collect(Collectors.toList());
    }

    @Override
    public void updateParticipantStatus(UUID roomId, UUID userId, String status) {
        WebRtcParticipant participant = findParticipant(roomId, userId);
        
        WebRtcParticipant.ParticipantStatus newStatus = WebRtcParticipant.ParticipantStatus
                .valueOf(status.toUpperCase());
        
        participant.updateStatus(newStatus);
        webRtcParticipantRepository.save(participant);
        
        // 상태 변경을 다른 참가자들에게 브로드캐스트
        notifyParticipantStatusChanged(roomId, participant);
    }

    @Override
    public void updateConnectionStats(UUID roomId, WebRtcConnectionStatsResponse stats) {
        log.debug("연결 통계 업데이트: {}", roomId);
        
        // 메모리에 통계 저장
        sessionStats.put(roomId, stats);
        
        // 데이터베이스에 연결 정보 저장
        saveConnectionStats(roomId, stats);
        
        // 연결 품질이 나쁜 경우 알림
        if (stats.hasSignificantIssues()) {
            notifyConnectionIssues(roomId, stats);
        }
    }

    @Override
    public void toggleAudio(UUID roomId, UUID userId, boolean enabled) {
        WebRtcParticipant participant = findParticipant(roomId, userId);
        
        participant.setIsMicrophoneEnabled(enabled);
        webRtcParticipantRepository.save(participant);
        
        // 다른 참가자들에게 알림
        WebRtcSignalingMessage message = WebRtcSignalingMessage.builder()
                .sessionId(roomId)
                .userId(userId)
                .type(enabled ? "unmute" : "mute")
                .data("{}")
                .timestamp(System.currentTimeMillis())
                .build();
        
        broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/audio", message);
    }

    @Override
    public void toggleVideo(UUID roomId, UUID userId, boolean enabled) {
        WebRtcParticipant participant = findParticipant(roomId, userId);
        
        participant.setIsCameraEnabled(enabled);
        webRtcParticipantRepository.save(participant);
        
        // 다른 참가자들에게 알림
        WebRtcSignalingMessage message = WebRtcSignalingMessage.builder()
                .sessionId(roomId)
                .userId(userId)
                .type(enabled ? "video-on" : "video-off")
                .data("{}")
                .timestamp(System.currentTimeMillis())
                .build();
        
        broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/video", message);
    }

    @Override
    public void toggleScreenShare(UUID roomId, UUID userId, boolean enabled) {
        WebRtcParticipant participant = findParticipant(roomId, userId);
        
        participant.setIsScreenSharing(enabled);
        webRtcParticipantRepository.save(participant);
        
        // 화면 공유는 한 명만 가능하도록 제한
        if (enabled) {
            disableOtherScreenShares(roomId, userId);
        }
        
        // 다른 참가자들에게 알림
        WebRtcSignalingMessage message = WebRtcSignalingMessage.builder()
                .sessionId(roomId)
                .userId(userId)
                .type(enabled ? "screen-share-start" : "screen-share-stop")
                .data("{}")
                .timestamp(System.currentTimeMillis())
                .build();
        
        broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/screen", message);
    }

    @Override
    public void kickParticipant(UUID roomId, UUID hostId, UUID targetUserId) {
        // 호스트 권한 확인
        WebRtcParticipant host = findParticipant(roomId, hostId);
        if (!Boolean.TRUE.equals(host.getIsHost()) && !Boolean.TRUE.equals(host.getIsModerator())) {
            throw new IllegalArgumentException("참가자를 내보낼 권한이 없습니다.");
        }
        
        WebRtcParticipant target = findParticipant(roomId, targetUserId);
        
        // 대상 참가자 강제 퇴장
        target.kick();
        webRtcParticipantRepository.save(target);
        
        // 강제 퇴장 알림
        notifyParticipantKicked(roomId, target, host);
        
        // 활성 연결에서 제거
        Set<UUID> roomConnections = activeConnections.get(roomId.toString());
        if (roomConnections != null) {
            roomConnections.remove(targetUserId);
        }
    }

    @Override
    public void muteParticipant(UUID roomId, UUID hostId, UUID targetUserId) {
        // 호스트 권한 확인
        WebRtcParticipant host = findParticipant(roomId, hostId);
        if (!Boolean.TRUE.equals(host.getIsHost()) && !Boolean.TRUE.equals(host.getIsModerator())) {
            throw new IllegalArgumentException("참가자를 음소거할 권한이 없습니다.");
        }
        
        WebRtcParticipant target = findParticipant(roomId, targetUserId);
        target.setIsMicrophoneEnabled(false);
        webRtcParticipantRepository.save(target);
        
        // 강제 음소거 알림
        notifyParticipantForceMuted(roomId, target, host);
    }

    @Override
    public WebRtcConnectionStatsResponse getRoomStats(UUID roomId) {
        // 메모리에서 최신 통계 조회
        WebRtcConnectionStatsResponse stats = sessionStats.get(roomId);
        if (stats != null) {
            return stats;
        }
        
        // 통계가 없으면 현재 상태 기반으로 생성
        return generateCurrentStats(roomId);
    }

    @Override
    public void recordSpeakingTime(UUID roomId, UUID userId, int seconds) {
        WebRtcParticipant participant = findParticipant(roomId, userId);
        participant.addSpeakingTime(seconds);
        participant.setLastSpokeAt(LocalDateTime.now());
        webRtcParticipantRepository.save(participant);
    }

    @Override
    public void updateNetworkQuality(UUID roomId, UUID userId, String quality, int signalStrength) {
        WebRtcParticipant participant = findParticipant(roomId, userId);
        participant.updateNetworkQuality(quality, signalStrength);
        webRtcParticipantRepository.save(participant);
        
        // 연결 품질이 나쁜 경우 알림
        if ("poor".equals(quality) || signalStrength <= 2) {
            notifyPoorConnection(roomId, participant);
        }
    }

    @Override
    public List<WebRtcParticipantResponse> getActiveParticipants(UUID roomId) {
        Set<UUID> activeUserIds = activeConnections.get(roomId.toString());
        if (activeUserIds == null || activeUserIds.isEmpty()) {
            return List.of();
        }
        
        SessionRoom room = sessionRoomRepository.findById(roomId)
                .orElseThrow(() -> new NotFoundException("세션 방을 찾을 수 없습니다."));
        
        List<WebRtcParticipant> participants = webRtcParticipantRepository
                .findActiveParticipantsByRoom(room);
        
        return participants.stream()
                .filter(p -> activeUserIds.contains(p.getUser().getUserId()))
                .map(this::convertToParticipantResponse)
                .collect(Collectors.toList());
    }

    @Override
    public void cleanupInactiveConnections(UUID roomId, long timeoutMinutes) {
        LocalDateTime cutoff = LocalDateTime.now().minusMinutes(timeoutMinutes);
        
        SessionRoom room = sessionRoomRepository.findById(roomId)
                .orElseThrow(() -> new NotFoundException("세션 방을 찾을 수 없습니다."));
        
        List<WebRtcParticipant> inactiveParticipants = webRtcParticipantRepository
                .findInactiveParticipants(room, cutoff);
        
        for (WebRtcParticipant participant : inactiveParticipants) {
            participant.leave();
            webRtcParticipantRepository.save(participant);
            
            // 활성 연결에서 제거
            Set<UUID> roomConnections = activeConnections.get(roomId.toString());
            if (roomConnections != null) {
                roomConnections.remove(participant.getUser().getUserId());
            }
            
            log.info("비활성 참가자 정리: {} - {}", participant.getUser().getUserId(), roomId);
        }
        
        updateSessionStats(roomId);
    }

    // === Private Helper Methods ===

    private WebRtcParticipant findParticipant(UUID roomId, UUID userId) {
        SessionRoom room = sessionRoomRepository.findById(roomId)
                .orElseThrow(() -> new NotFoundException("세션 방을 찾을 수 없습니다."));
        
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new NotFoundException("사용자를 찾을 수 없습니다."));
        
        return webRtcParticipantRepository.findBySessionRoomAndUser(room, user)
                .orElseThrow(() -> new NotFoundException("참가자를 찾을 수 없습니다."));
    }

    private String generateConnectionId() {
        return "conn_" + System.currentTimeMillis() + "_" + UUID.randomUUID().toString().substring(0, 8);
    }

    private String extractDeviceInfo(String userAgent) {
        if (userAgent == null) return "Unknown Device";
        
        if (userAgent.contains("Mobile")) return "Mobile Device";
        if (userAgent.contains("Tablet")) return "Tablet";
        return "Desktop";
    }

    private boolean isValidSignalingMessage(WebRtcSignalingMessage message) {
        return message != null &&
               message.getSessionId() != null &&
               message.getUserId() != null &&
               message.getType() != null &&
               message.getData() != null;
    }

    private void handleWebRtcSignal(UUID roomId, WebRtcSignalingMessage message) {
        // WebRTC 시그널 메시지를 대상 사용자에게 전달
        if (message.getTargetUserId() != null) {
            // P2P 메시지
            messagingTemplate.convertAndSend(
                "/topic/webrtc/" + roomId + "/signal/" + message.getTargetUserId(),
                message
            );
        } else {
            // 브로드캐스트 메시지
            broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/signal", message);
        }
    }

    private void handleAudioControl(UUID roomId, WebRtcSignalingMessage message) {
        boolean enabled = "unmute".equals(message.getType());
        toggleAudio(roomId, message.getUserId(), enabled);
    }

    private void handleVideoControl(UUID roomId, WebRtcSignalingMessage message) {
        boolean enabled = "video-on".equals(message.getType());
        toggleVideo(roomId, message.getUserId(), enabled);
    }

    private void handleScreenShare(UUID roomId, WebRtcSignalingMessage message) {
        boolean enabled = "screen-share-start".equals(message.getType());
        toggleScreenShare(roomId, message.getUserId(), enabled);
    }

    private void broadcastToRoom(UUID roomId, String destination, Object message) {
        messagingTemplate.convertAndSend(destination, message);
    }

    private WebRtcParticipantResponse convertToParticipantResponse(WebRtcParticipant participant) {
        User user = participant.getUser();
        
        return WebRtcParticipantResponse.builder()
                .userId(user.getUserId())
                .displayName(user.getEnglishName())
                .profileImageUrl(user.getProfileImage())
                .connectionId(participant.getConnectionId())
                .status(participant.getStatus().name().toLowerCase())
                .joinedAt(participant.getJoinedAt())
                .lastActiveAt(participant.getLastActiveAt())
                .isHost(participant.getIsHost())
                .isModerator(participant.getIsModerator())
                .canSpeak(participant.getCanSpeak())
                .canViewScreen(participant.getCanViewScreen())
                .canControlMedia(participant.getCanControlMedia())
                .isCameraEnabled(participant.getIsCameraEnabled())
                .isMicrophoneEnabled(participant.getIsMicrophoneEnabled())
                .isScreenSharing(participant.getIsScreenSharing())
                .isSpeaking(participant.getIsSpeaking())
                .connectionQuality(participant.getConnectionQuality())
                .signalStrength(participant.getSignalStrength())
                .isConnected(participant.getIsConnected())
                .networkType(participant.getNetworkType())
                .speakingTimeSeconds(participant.getSpeakingTimeSeconds())
                .lastSpokeAt(participant.getLastSpokeAt())
                .userAgent(participant.getUserAgent())
                .deviceInfo(participant.getDeviceInfo())
                .nativeLanguage(user.getNativeLanguage() != null ? user.getNativeLanguage().getName() : null)
                .build();
    }

    private void notifyParticipantJoined(UUID roomId, WebRtcParticipant participant) {
        WebRtcParticipantResponse response = convertToParticipantResponse(participant);
        broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/participant-joined", response);
    }

    private void notifyParticipantLeft(UUID roomId, WebRtcParticipant participant) {
        WebRtcParticipantResponse response = convertToParticipantResponse(participant);
        broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/participant-left", response);
    }

    private void notifyParticipantStatusChanged(UUID roomId, WebRtcParticipant participant) {
        WebRtcParticipantResponse response = convertToParticipantResponse(participant);
        broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/participant-status", response);
    }

    private void notifyParticipantKicked(UUID roomId, WebRtcParticipant target, WebRtcParticipant host) {
        Map<String, Object> notification = Map.of(
            "type", "participant-kicked",
            "target", convertToParticipantResponse(target),
            "host", convertToParticipantResponse(host),
            "timestamp", System.currentTimeMillis()
        );
        
        broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/moderation", notification);
    }

    private void notifyParticipantForceMuted(UUID roomId, WebRtcParticipant target, WebRtcParticipant host) {
        Map<String, Object> notification = Map.of(
            "type", "participant-muted",
            "target", convertToParticipantResponse(target),
            "host", convertToParticipantResponse(host),
            "timestamp", System.currentTimeMillis()
        );
        
        broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/moderation", notification);
    }

    private void notifyConnectionIssues(UUID roomId, WebRtcConnectionStatsResponse stats) {
        Map<String, Object> notification = Map.of(
            "type", "connection-issues",
            "issues", stats.getQualityIssues(),
            "suggestions", stats.getOptimizationSuggestions(),
            "timestamp", System.currentTimeMillis()
        );
        
        broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/quality", notification);
    }

    private void notifyPoorConnection(UUID roomId, WebRtcParticipant participant) {
        Map<String, Object> notification = Map.of(
            "type", "poor-connection",
            "participant", convertToParticipantResponse(participant),
            "timestamp", System.currentTimeMillis()
        );
        
        messagingTemplate.convertAndSend(
            "/topic/webrtc/" + roomId + "/quality/" + participant.getUser().getUserId(),
            notification
        );
    }

    private void promoteNewHost(UUID roomId) {
        SessionRoom room = sessionRoomRepository.findById(roomId)
                .orElseThrow(() -> new NotFoundException("세션 방을 찾을 수 없습니다."));
        
        List<WebRtcParticipant> activeParticipants = webRtcParticipantRepository
                .findActiveParticipantsByRoom(room);
        
        if (!activeParticipants.isEmpty()) {
            WebRtcParticipant newHost = activeParticipants.get(0);
            newHost.setIsHost(true);
            newHost.setIsModerator(true);
            webRtcParticipantRepository.save(newHost);
            
            // 새 호스트 알림
            broadcastToRoom(roomId, "/topic/webrtc/" + roomId + "/host-changed", 
                convertToParticipantResponse(newHost));
        }
    }

    private void disableOtherScreenShares(UUID roomId, UUID userId) {
        SessionRoom room = sessionRoomRepository.findById(roomId)
                .orElseThrow(() -> new NotFoundException("세션 방을 찾을 수 없습니다."));
        
        List<WebRtcParticipant> sharingParticipants = webRtcParticipantRepository
                .findBySessionRoomAndIsScreenSharingTrue(room);
        
        for (WebRtcParticipant participant : sharingParticipants) {
            if (!participant.getUser().getUserId().equals(userId)) {
                participant.setIsScreenSharing(false);
                webRtcParticipantRepository.save(participant);
            }
        }
    }

    private void updateSessionStats(UUID roomId) {
        // 현재 세션 통계 업데이트 로직
        WebRtcConnectionStatsResponse stats = generateCurrentStats(roomId);
        sessionStats.put(roomId, stats);
    }

    private WebRtcConnectionStatsResponse generateCurrentStats(UUID roomId) {
        SessionRoom room = sessionRoomRepository.findById(roomId)
                .orElseThrow(() -> new NotFoundException("세션 방을 찾을 수 없습니다."));
        
        List<WebRtcParticipant> participants = webRtcParticipantRepository
                .findActiveParticipantsByRoom(room);
        
        Set<UUID> activeUserIds = activeConnections.get(roomId.toString());
        int activeCount = activeUserIds != null ? activeUserIds.size() : 0;
        
        return WebRtcConnectionStatsResponse.builder()
                .sessionId(room.getSessionId())
                .roomId(roomId)
                .timestamp(LocalDateTime.now())
                .totalParticipants(participants.size())
                .activeParticipants(activeCount)
                .connectedParticipants(activeCount)
                .sessionDurationMinutes((long) room.getDurationMinutes())
                .overallConnectionQuality(calculateOverallQuality(participants))
                .sessionQualityScore(calculateSessionQuality(participants))
                .qualityIssues(List.of())
                .performanceRecommendations(List.of())
                .build();
    }

    private String calculateOverallQuality(List<WebRtcParticipant> participants) {
        long excellentCount = participants.stream()
                .mapToLong(p -> "excellent".equals(p.getConnectionQuality()) ? 1L : 0L)
                .sum();
        
        double excellentRatio = (double) excellentCount / participants.size();
        
        if (excellentRatio >= 0.8) return "excellent";
        if (excellentRatio >= 0.6) return "good";
        if (excellentRatio >= 0.4) return "fair";
        return "poor";
    }

    private Double calculateSessionQuality(List<WebRtcParticipant> participants) {
        if (participants.isEmpty()) return 0.0;
        
        double totalScore = participants.stream()
                .mapToDouble(p -> {
                    double score = 50.0; // 기본 점수
                    
                    // 연결 품질 기반 점수
                    switch (p.getConnectionQuality() != null ? p.getConnectionQuality() : "unknown") {
                        case "excellent" -> score += 30;
                        case "good" -> score += 20;
                        case "fair" -> score += 10;
                        case "poor" -> score += 0;
                        default -> score += 5;
                    }
                    
                    // 참여도 기반 점수
                    if (Boolean.TRUE.equals(p.getIsMicrophoneEnabled())) score += 10;
                    if (Boolean.TRUE.equals(p.getIsCameraEnabled())) score += 10;
                    
                    return Math.min(100.0, score);
                })
                .sum();
        
        return totalScore / participants.size();
    }

    private void saveConnectionStats(UUID roomId, WebRtcConnectionStatsResponse stats) {
        // 연결 통계를 데이터베이스에 저장 (향후 구현)
        // WebRtcConnection 엔티티에 통계 정보 저장
        log.debug("연결 통계 저장: {} - 품질: {}", roomId, stats.getOverallConnectionQuality());
    }
}